package app

import (
	"bufio"
	"fmt"
	"image"
	"image/color"
	"image/draw"
	"image/gif"
	"io"
	"os"
	"path/filepath"
	"strconv"
	"time"

	"github.com/JoaoGarcia/Mezzotone/internal/services"
	"github.com/JoaoGarcia/Mezzotone/internal/termtext"
	"github.com/JoaoGarcia/Mezzotone/internal/ui"
	"github.com/charmbracelet/bubbles/filepicker"
	"github.com/charmbracelet/bubbles/key"
	"github.com/charmbracelet/bubbles/viewport"
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
	"github.com/google/uuid"
	"golang.design/x/clipboard"
)

// TODO REORDER Layout IF TERMINAL width < height
// FIXME for some fontsize image gets cut on right side
// TODO image preview on selected file (maybe ?)
// TODO maybe add fullscreenish to renderview
// TODO add color toggle (current is no color)
// todo make it ⭐prettier⭐

type MezzotoneModel struct {
	filePicker   filepicker.Model
	selectedFile string

	renderView      viewport.Model
	leftColumn      viewport.Model
	renderSettings  ui.SettingsPanel
	messageViewPort viewport.Model

	style styleVariables

	currentActiveMenu int
	helpVisible       bool
	helpPreviousMenu  int
	renderContent     string

	gifAnimation ui.AnimationRenderer

	width  int
	height int

	err error
}

type styleVariables struct {
	windowMargin    int
	leftColumnWidth int
}

var renderSettingsItemsSize int
var clipboardOK bool
var newUUID = uuid.New

const (
	filePickerMenu = iota
	renderOptionsMenu
	renderViewText
)

func NewMezzotoneModel() *MezzotoneModel {
	windowStyles := styleVariables{
		windowMargin: 2,
	}

	runeMode := []string{"ASCII", "UNICODE", "DOTS", "RECTANGLES", "BARS", "LOADING"}
	renderSettingsItems := []ui.SettingItem{
		{Label: "Text Size", Key: "textSize", Type: ui.TypeInt, Value: "10"},
		{Label: "Font Aspect", Key: "fontAspect", Type: ui.TypeFloat, Value: "2.3"},
		{Label: "Directional Render", Key: "directionalRender", Type: ui.TypeBool, Value: "FALSE"},
		{Label: "Edge Threshold", Key: "edgeThreshold", Type: ui.TypeFloat, Value: "0.6"},
		{Label: "Reverse Chars", Key: "reverseChars", Type: ui.TypeBool, Value: "TRUE"},
		{Label: "High Contrast", Key: "highContrast", Type: ui.TypeBool, Value: "TRUE"},
		{Label: "Rune Mode", Key: "runeMode", Type: ui.TypeEnum, Value: "ASCII", Enum: runeMode},
	}
	renderSettingsItemsSize = len(renderSettingsItems)
	renderSettingsModel := ui.NewSettingsPanel("Render Options", renderSettingsItems)
	renderSettingsModel.ClearActive()

	fp := filepicker.New()
	fp.AllowedTypes = []string{".png", ".jpg", ".jpeg", ".bmp", ".webp", ".tiff", ".gif"}
	fp.CurrentDirectory, _ = os.UserHomeDir()
	fp.ShowPermissions = false
	fp.ShowSize = true
	fp.KeyMap = filepicker.KeyMap{
		Down:     key.NewBinding(key.WithKeys("j", "down"), key.WithHelp("j", "down")),
		Up:       key.NewBinding(key.WithKeys("k", "up"), key.WithHelp("k", "up")),
		GoToTop:  key.NewBinding(key.WithKeys("K", "pgup"), key.WithHelp("pgup", "page up")),
		GoToLast: key.NewBinding(key.WithKeys("J", "pgdown"), key.WithHelp("pgdown", "page down")),
		Back:     key.NewBinding(key.WithKeys("left", "backspace"), key.WithHelp("h", "back")),
		Open:     key.NewBinding(key.WithKeys("right", "enter"), key.WithHelp("l", "open")),
		Select:   key.NewBinding(key.WithKeys("enter"), key.WithHelp("enter", "select")),
	}

	renderView := viewport.New(0, 0)
	leftColumn := viewport.New(0, 0)

	messageViewPort := viewport.New(0, 3)

	model := &MezzotoneModel{
		filePicker:        fp,
		renderView:        renderView,
		messageViewPort:   messageViewPort,
		style:             windowStyles,
		leftColumn:        leftColumn,
		renderSettings:    renderSettingsModel,
		currentActiveMenu: filePickerMenu,
		helpPreviousMenu:  filePickerMenu,
	}
	model.updateMessageViewPortContent("Select image, gif or video to convert:", false)

	if err := clipboard.Init(); err == nil {
		clipboardOK = true
	}

	return model
}

func (m *MezzotoneModel) Init() tea.Cmd {
	return m.filePicker.Init()
}

func (m *MezzotoneModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var (
		cmd  tea.Cmd
		cmds []tea.Cmd
	)

	switch msg := msg.(type) {
	case ui.TickMsg:
		if !m.gifAnimation.IsAnimationPlaying() {
			return m, nil
		}
		var c tea.Cmd
		m.gifAnimation, c = m.gifAnimation.Update(msg)
		if !m.helpVisible {
			m.renderContent = m.gifAnimation.View()
			m.renderView.SetContent(m.renderContent)
		}
		return m, c

	case tea.WindowSizeMsg:
		m.width, m.height = msg.Width, msg.Height

		m.renderView.Height = m.height - m.style.windowMargin
		m.renderView.Width = m.width / 7 * 5

		m.style.leftColumnWidth = m.width / 7 * 2

		m.renderSettings.SetWidth(m.style.leftColumnWidth)
		m.renderSettings.SetHeight(renderSettingsItemsSize)

		m.messageViewPort.Width = m.style.leftColumnWidth

		computedFilePickerHeight := m.renderView.Height -
			(renderSettingsItemsSize + 4) - //renderSettings header and end
			(m.messageViewPort.Height + 2) - //message render view
			(m.style.windowMargin + 3) //inputFile Title

		m.filePicker.SetHeight(computedFilePickerHeight)

		m.updateMessageViewPortContent("Select image, gif or video to convert:", false)

		return m, nil

	case tea.KeyMsg:
		switch msg.String() {
		case "c":
			if m.currentActiveMenu == renderViewText {
				if !clipboardOK {
					m.updateMessageViewPortContent("Clipboard not available (init failed)", true)
					return m, nil
				}

				clipboard.Write(clipboard.FmtText, []byte(m.renderContent))
				m.updateMessageViewPortContent("Successfully sent to clipboard !", false)
				return m, nil
			}
		case "e":
			if m.currentActiveMenu == renderViewText {
				homeDir, err := os.UserHomeDir()
				generatedUuid := newUUID()
				path := filepath.Join(homeDir, "Mezzotone_"+generatedUuid.String()+".txt")
				f, err := os.Create(path)
				if err != nil {
					m.updateMessageViewPortContent("⚠ "+err.Error(), true)
					return m, nil
				}
				defer f.Close()

				f.WriteString(m.renderContent)
				w := bufio.NewWriter(f)
				w.Flush()

				m.updateMessageViewPortContent("Successfully exported to "+path+" !", false)
				return m, nil

			}
		case "h":
			if m.currentActiveMenu == renderOptionsMenu && m.renderSettings.Editing {
				break
			}
			if m.helpVisible {
				m.helpVisible = false
				m.currentActiveMenu = m.helpPreviousMenu
				m.renderView.SetContent(m.renderContent)
				return m, nil
			}
			m.helpVisible = true
			m.helpPreviousMenu = m.currentActiveMenu
			m.currentActiveMenu = renderViewText
			m.renderView.GotoTop()
			m.renderView.SetContent(buildRenderHelpText())
			return m, nil
		case "ctrl+c":
			return m, tea.Quit

		case "esc":
			if m.helpVisible {
				m.helpVisible = false
				m.currentActiveMenu = m.helpPreviousMenu
				m.renderView.SetContent(m.renderContent)
				return m, nil
			}
			if m.currentActiveMenu == filePickerMenu {
				//TODO ask for confimation
				return m, tea.Quit
			}
			if m.currentActiveMenu == renderOptionsMenu {
				if !m.renderSettings.Editing {
					m.decrementCurrentActiveMenu()
					m.renderSettings.ClearActive()
				}
				return m, cmd
			}
			if m.currentActiveMenu == renderViewText {
				m.decrementCurrentActiveMenu()
				return m, cmd
			}

		case "enter":
			if m.currentActiveMenu == renderOptionsMenu {
				if !m.renderSettings.Editing && m.renderSettings.Confirm {
					m.incrementCurrentActiveMenu()

					normalizedOptions, err := normalizeRenderOptionsForService(m.renderSettings.Items)
					if err != nil {
						m.updateMessageViewPortContent("⚠ "+err.Error(), true)
					}

					f, err := os.Open(m.selectedFile)
					if err != nil {
						m.updateMessageViewPortContent("⚠ "+err.Error(), true)
						return m, cmd
					}
					defer func() { _ = f.Close() }()

					_ = services.Logger().Info(fmt.Sprintf("Successfully Loaded: %s", m.selectedFile))

					if IsGIF(m.selectedFile) {
						frameArray, delays, err := SplitAnimatedGIF(f)
						if err != nil {
							m.updateMessageViewPortContent("⚠ "+err.Error(), true)
							return m, cmd
						}

						var gifRuneArrays [][][]rune
						for _, frame := range frameArray {
							runeArray, err := services.ConvertImageToString(frame, normalizedOptions)
							if err != nil {
								m.updateMessageViewPortContent("⚠ "+err.Error(), true)
								return m, cmd
							}
							gifRuneArrays = append(gifRuneArrays, runeArray)
						}

						var animationFrames []ui.AnimationFrame
						for i, frameRuneArray := range gifRuneArrays {
							animationFrames = append(
								animationFrames,
								ui.AnimationFrame{
									Frame:    services.ImageRuneArrayIntoString(frameRuneArray),
									Duration: time.Duration(delays[i]) * 10 * time.Millisecond,
								},
							)
						}
						_ = services.Logger().Info(fmt.Sprintf("%s", m.renderContent))

						var escapeKeys []string
						escapeKeys = append(escapeKeys, "esc")
						gifAnimation := ui.NewAnimationRenderer(animationFrames, escapeKeys)

						m.gifAnimation = gifAnimation

						return m, m.gifAnimation.StartAnimation
					}

					// else is Image
					inputImg, format, err := image.Decode(f)
					if err != nil {
						m.updateMessageViewPortContent("⚠ "+err.Error(), true)
						return m, cmd
					}
					_ = services.Logger().Info(fmt.Sprintf("format: %s", format))

					runeArray, err := services.ConvertImageToString(inputImg, normalizedOptions)
					if err != nil {
						m.updateMessageViewPortContent("⚠ "+err.Error(), true)
						return m, cmd
					}

					m.gifAnimation.StopAnimation()
					m.renderContent = services.ImageRuneArrayIntoString(runeArray)
					_ = services.Logger().Info(fmt.Sprintf("%s", m.renderContent))

					if !m.helpVisible {
						m.renderView.SetContent(m.renderContent)
					}
					return m, cmd
				}
			}
		case "left":
			if m.currentActiveMenu == renderViewText {
				m.renderView.ScrollLeft(1)
				return m, cmd
			}
		case "right":
			if m.currentActiveMenu == renderViewText {
				m.renderView.ScrollRight(1)
				return m, cmd
			}
		case "up":
			if m.currentActiveMenu == renderViewText {
				m.renderView.ScrollUp(1)
				return m, cmd
			}
		case "down":
			if m.currentActiveMenu == renderViewText {
				m.renderView.ScrollDown(1)
				return m, cmd
			}
		case "pgdown":
			if m.currentActiveMenu == renderOptionsMenu {
				m.renderSettings.SetActive(renderSettingsItemsSize)
				m.renderSettings.Confirm = true
				return m, cmd
			}
		case "pgup":
			if m.currentActiveMenu == renderOptionsMenu {
				m.renderSettings.SetActive(0)
				m.renderSettings.Confirm = false
				return m, cmd
			}
		}
	}

	if m.currentActiveMenu == filePickerMenu {
		m.filePicker, cmd = m.filePicker.Update(msg)
		cmds = append(cmds, cmd)
		if didSelect, path := m.filePicker.DidSelectFile(msg); didSelect {
			m.selectedFile = path
			_ = services.Logger().Info(fmt.Sprintf("Selected File: %s", m.selectedFile))

			m.renderSettings.SetActive(0)
			m.renderSettings.Confirm = false
			m.incrementCurrentActiveMenu()
			return m, cmd
		}

		if didSelect, path := m.filePicker.DidSelectDisabledFile(msg); didSelect {
			m.updateMessageViewPortContent("⚠ Selected file not allowed", true)
			m.selectedFile = ""
			_ = services.Logger().Info(fmt.Sprintf("Tried Selecting File: %s", path))
			return m, cmd
		}
	}
	if m.currentActiveMenu == renderOptionsMenu {
		m.renderSettings, cmd = m.renderSettings.Update(msg)
		if errMsg := m.renderSettings.ErrorMessage(); errMsg != "" {
			m.updateMessageViewPortContent("⚠ "+errMsg, true)
		} else {
			m.updateMessageViewPortContent("Edit render options and confirm:", false)
		}
		return m, cmd
	}
	if m.currentActiveMenu == renderViewText {
		m.renderView, cmd = m.renderView.Update(msg)
		return m, cmd
	}

	return m, cmd
}

func (m *MezzotoneModel) View() string {
	innerW := m.style.leftColumnWidth - 2

	messageViewportRenderStyle := lipgloss.NewStyle().
		BorderStyle(lipgloss.NormalBorder()).
		Width(m.style.leftColumnWidth)
	messageViewportRender := messageViewportRenderStyle.Render(m.messageViewPort.View())

	filePickerStyle := lipgloss.NewStyle().
		BorderStyle(lipgloss.NormalBorder()).
		Width(m.style.leftColumnWidth)
	fpView := termtext.TruncateLinesANSI(m.filePicker.View(), innerW)
	filePickerRender := filePickerStyle.Render(fpView)

	lefColumnRender := lipgloss.JoinVertical(lipgloss.Top, messageViewportRender, filePickerRender, m.renderSettings.View())

	renderViewStyle := lipgloss.NewStyle().
		BorderStyle(lipgloss.NormalBorder())
	renderViewRender := renderViewStyle.Render(m.renderView.View())

	return lipgloss.JoinHorizontal(lipgloss.Left, lefColumnRender, renderViewRender)
}

func normalizeRenderOptionsForService(settingsValues []ui.SettingItem) (services.RenderOptions, error) {
	var textSize int
	var fontAspect, edgeThreshold float64
	var directionalRender, reverseChars, highContrast bool
	var runeMode string

	for _, item := range settingsValues {
		switch item.Key {
		case "textSize":
			textSize, _ = strconv.Atoi(item.Value)

		case "fontAspect":
			fontAspect, _ = strconv.ParseFloat(item.Value, 2)

		case "edgeThreshold":
			edgeThreshold, _ = strconv.ParseFloat(item.Value, 2)

		case "directionalRender":
			directionalRender, _ = strconv.ParseBool(item.Value)

		case "reverseChars":
			reverseChars, _ = strconv.ParseBool(item.Value)

		case "highContrast":
			highContrast, _ = strconv.ParseBool(item.Value)

		case "runeMode":
			runeMode = item.Value
		}
	}
	options, err := services.NewRenderOptions(textSize, fontAspect, directionalRender, edgeThreshold, reverseChars, highContrast, runeMode)
	if err != nil {
		return services.RenderOptions{}, err
	}
	return options, nil
}

func (m *MezzotoneModel) incrementCurrentActiveMenu() {
	m.currentActiveMenu++

	var messageViewContent string
	switch m.currentActiveMenu {
	case filePickerMenu:
		messageViewContent = "Select image, gif or video to convert:"
		break
	case renderOptionsMenu:
		messageViewContent = "Edit render options and confirm:"
		break
	case renderViewText:
		messageViewContent = "Press e to Export or c to copy to clipboard"
		break
	}

	m.messageViewPort.SetContent(
		termtext.TruncateLinesANSI(
			messageViewContent+lipgloss.NewStyle().Faint(true).Render("\nPress h to toggle Help. Press esc to Quit."),
			m.style.leftColumnWidth,
		),
	)
}

func (m *MezzotoneModel) decrementCurrentActiveMenu() {
	m.currentActiveMenu--

	var messageViewContent string
	switch m.currentActiveMenu {
	case filePickerMenu:
		messageViewContent = "Select image gif or video to convert:"
		break
	case renderOptionsMenu:
		messageViewContent = "Edit render options and confirm:"
		break
	case renderViewText:
		messageViewContent = "Rendered image"
		break
	}

	m.messageViewPort.SetContent(
		termtext.TruncateLinesANSI(
			messageViewContent+lipgloss.NewStyle().Faint(true).Render("\nPress h to toggle Help. Press esc to Quit."),
			m.style.leftColumnWidth,
		),
	)
}

func (m *MezzotoneModel) updateMessageViewPortContent(messageViewContent string, isError bool) {
	if isError {
		messageViewContent = lipgloss.NewStyle().
			Foreground(lipgloss.Color("9")).
			Render(messageViewContent)
	}

	m.messageViewPort.SetContent(
		termtext.TruncateLinesANSI(
			messageViewContent+lipgloss.NewStyle().Faint(true).Render("\nPress h to toggle Help. Press esc to Quit."),
			m.style.leftColumnWidth,
		),
	)
}

// GIF LOGIC //

func IsGIF(path string) bool {
	f, err := os.Open(path)
	if err != nil {
		return false
	}
	defer f.Close()

	_, format, err := image.DecodeConfig(f)
	if err != nil {
		return false
	}

	return format == "gif"
}

// SplitAnimatedGIF decodes an animated GIF and returns fully-composited frames plus per-frame delays.
// GIF frames are often partial/offset “patches”, so we simulate playback by drawing each frame onto a
// full-size RGBA canvas (respecting transparency + disposal rules), cloning the canvas after each draw
// so frames don’t share the same pixel buffer. Delays are in 1/100s (e.g., 5 => 50ms).
func SplitAnimatedGIF(r io.Reader) (frames []image.Image, delays []int, err error) {
	defer func() {
		if rec := recover(); rec != nil {
			err = fmt.Errorf("panic while decoding gif: %v", rec)
		}
	}()

	g, err := gif.DecodeAll(r)
	if err != nil {
		return nil, nil, err
	}
	if len(g.Image) == 0 {
		return nil, nil, fmt.Errorf("gif has no frames")
	}

	w, h := g.Config.Width, g.Config.Height
	canvasBounds := image.Rect(0, 0, w, h)
	canvas := image.NewRGBA(canvasBounds)

	// Fill with background color (best-effort)
	bg := color.RGBA{}
	if len(g.Image[0].Palette) > 0 && int(g.BackgroundIndex) < len(g.Image[0].Palette) {
		r0, g0, b0, a0 := g.Image[0].Palette[g.BackgroundIndex].RGBA()
		bg = color.RGBA{uint8(r0 >> 8), uint8(g0 >> 8), uint8(b0 >> 8), uint8(a0 >> 8)}
	}
	draw.Draw(canvas, canvas.Bounds(), &image.Uniform{C: bg}, image.Point{}, draw.Src)

	// Delays: keep same length as frames; if missing, default to 0.
	delays = make([]int, 0, len(g.Image))

	// For "restore to previous" disposal
	var prevCanvas *image.RGBA

	for i, src := range g.Image {
		// Save canvas BEFORE drawing this frame if disposal asks to restore previous
		if len(g.Disposal) > i && g.Disposal[i] == gif.DisposalPrevious {
			prevCanvas = cloneRGBA(canvas)
		} else {
			prevCanvas = nil
		}

		// Draw this frame at its own offset (src.Bounds().Min)
		draw.Draw(canvas, src.Bounds(), src, src.Bounds().Min, draw.Over)

		// Snapshot AFTER drawing (clone!)
		frames = append(frames, cloneRGBA(canvas))

		// Record delay (1/100s)
		if len(g.Delay) > i {
			delays = append(delays, g.Delay[i])
		} else {
			delays = append(delays, 0)
		}

		// Apply disposal for next frame
		if len(g.Disposal) > i {
			switch g.Disposal[i] {
			case gif.DisposalBackground:
				draw.Draw(canvas, src.Bounds(), &image.Uniform{C: bg}, image.Point{}, draw.Src)
			case gif.DisposalPrevious:
				if prevCanvas != nil {
					canvas = prevCanvas
				}
			}
		}
	}

	return frames, delays, nil
}

func cloneRGBA(src *image.RGBA) *image.RGBA {
	dst := image.NewRGBA(src.Bounds())
	copy(dst.Pix, src.Pix)
	return dst
}

// END GIF LOGIC //
